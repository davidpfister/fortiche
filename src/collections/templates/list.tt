<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension="f90" #>
! Fortran Generic Collections
! Copyright (c) davidpfister
!
! All rights reserved.
! 
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are
! met:
! 
!  Redistributions of source code must retain the above copyright
! notice, this list of conditions and the following disclaimer.
!   Redistributions in binary form must reproduce the above
! copyright notice, this list of conditions and the following disclaimer
! in the documentation and/or other materials provided with the
! distribution.
!   Neither the name of original developer, nor the names of its
! contributors may be used to endorse or promote products derived from
! this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
! A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ======================================================================
! This code has been generated by a tool; do not edit manually. Instead,
! edit the T4 template so this file can be regenerated. 
! ======================================================================
#include "../include/list.inc"
<# 
    string[] kinds = { "integer", "real", "logical", "character" };
    string prefix = "";
    string[] types = {""}; 
    foreach (string knd in kinds) { #>

module <#=knd#>_list
    use iso_fortran_env

    implicit none; private

    public :: item_<#=knd#>, &
              add, &
              get, &
              insert, &
              clear, &
              remove, &
              assignment(=), &
              sizeof
<#  if (knd == "integer") 
{
    types = new string[4]{ "int8", "int16", "int32", "int64" };
} else if (knd == "real") {
    types = new string[3]{ "real32", "real64", "real128" };
} else if (knd == "character") {
    types = new string[1]{ "char8" };
    prefix = "len=*, ";
} else if (knd == "logical") {
    types = new string[1]{ "log32" };
} #>

<# if (knd == "character") { #>
    integer, parameter :: char8 = kind('a') 
<# } else if (knd == "logical") { #>
    integer, parameter :: log32 = kind(.true.)
<# } #>

    type item_<#=knd#>(k)
<# if (knd == "integer") { #>
        integer, kind :: k = kind(1_int32)
        integer(kind=k) :: content
<# } else if (knd == "real") { #>
        integer, kind :: k = kind(1.0_real64)
        real(kind=k) :: content
<# } else if (knd == "character") { #>
        integer, kind :: k = kind('a')
        character(len=:, kind=k), allocatable :: content
<# } else if (knd == "logical") { #>
        integer, kind :: k = kind(.true.)
        logical(kind=k) :: content
<# } #>
    end type

	interface assignment(=)
<# foreach (string a in types) { #>
        module procedure :: assign_item_<#=a#>
<# } #>
    end interface

    interface add
<# foreach (string a in types) { #>
        module procedure :: add_item_<#=a#>
        module procedure :: add_range_<#=a#>
<# } #>
    end interface

    interface clear
<# foreach (string a in types) { #>
        module procedure  :: clear_item_<#=a#>
<# } #>
    end interface
    
    interface get
<# foreach (string a in types) { #>
        module procedure  :: get_item_<#=a#>
<# } #>
    end interface
    
    interface insert
<# foreach (string a in types) { #>
        module procedure :: insert_item_<#=a#>
<# } #>
    end interface
    
    interface remove
<# foreach (string a in types) { #>
        module procedure :: remove_item_<#=a#>
<# } #>
    end interface
    
    interface sizeof
<# foreach (string a in types) { #>
        module procedure  :: size_item_<#=a#>
<# } #>
    end interface
	
	contains

<# foreach (string a in types) { #>	
	subroutine assign_item_<#=a#>(lhs, rhs)
        <#=knd#>(<#=prefix#>kind=<#=a#>), intent(inout)            ::  lhs
        class(item_<#=knd#>(<#=a#>)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine
<# } #>

<# foreach (string a in types) { #>	
	subroutine add_to_<#=a#>(vec, val, n, chunk_size, finished)
        type(item_<#=knd#>(<#=a#>)), allocatable, intent(inout) :: vec(:)
        <#=knd#>(<#=prefix#>kind=<#=a#>), intent(in)                    		   :: val
        integer, intent(inout)                  			   :: n
        integer, intent(in)                     			   :: chunk_size
        logical, intent(in)                     			   :: finished
        !private
        type(item_<#=knd#>(<#=a#>)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine
<# } #>

<# foreach (string a in types) { #>	
	subroutine add_item_<#=a#>(this, arg)
        type(item_<#=knd#>(<#=a#>)), intent(inout), allocatable  :: this(:)
        <#=knd#>(<#=prefix#>kind=<#=a#>), intent(in)                     		:: arg
        !private
        integer :: count
        count = size(this)
        call add_to_<#=a#>(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine
<# } #>

<# foreach (string a in types) { #>	
	subroutine add_range_<#=a#>(this, args)
        type(item_<#=knd#>(<#=a#>)), intent(inout), allocatable  :: this(:)
        <#=knd#>(<#=prefix#>kind=<#=a#>), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_<#=a#>(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine
<# } #>

<# foreach (string a in types) { #>	
	subroutine clear_item_<#=a#>(this)
        type(item_<#=knd#>(<#=a#>)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_<#=knd#>(<#=a#>)), allocatable :: tmp(:)
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine
<# } #>

<# foreach (string a in types) { #>	
	function get_item_<#=a#>(this, key) result(res)
        type(item_<#=knd#>(<#=a#>)), intent(inout) :: this(:)
        integer, intent(in) :: key
<# if (knd == "character") { #>
        <#=knd#>(len=:, kind=<#=a#>), allocatable :: res
<# } else { #>
        <#=knd#>(<#=prefix#>kind=<#=a#>), allocatable :: res
<# } #>
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function
<# } #>

<# foreach (string a in types) { #>	
	subroutine insert_item_<#=a#>(this, i, arg)
        type(item_<#=knd#>(<#=a#>)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                      :: i
        <#=knd#>(<#=prefix#>kind=<#=a#>), intent(in)                     :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_<#=a#>(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine
<# } #>

<# foreach (string a in types) { #>	
	subroutine remove_item_<#=a#>(this, i)
        type(item_<#=knd#>(<#=a#>)), intent(inout), allocatable    :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_<#=knd#>(<#=a#>)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine
<# } #>

<# foreach (string a in types) { #>	
	integer function size_item_<#=a#>(this) result(res)
        type(item_<#=knd#>(<#=a#>)), intent(inout), allocatable :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
<# } #>
end module
<# } #>

module intrinsic_list
<# foreach (string knd in kinds) { #>
    use <#=knd#>_list
<# } #>
end module