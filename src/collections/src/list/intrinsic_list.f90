! Fortran Generic Collections
! Copyright (c) davidpfister
!
! All rights reserved.
! 
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are
! met:
! 
!  Redistributions of source code must retain the above copyright
! notice, this list of conditions and the following disclaimer.
!   Redistributions in binary form must reproduce the above
! copyright notice, this list of conditions and the following disclaimer
! in the documentation and/or other materials provided with the
! distribution.
!   Neither the name of original developer, nor the names of its
! contributors may be used to endorse or promote products derived from
! this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
! A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ======================================================================
! This code has been generated by a tool; do not edit manually. Instead,
! edit the T4 template so this file can be regenerated. 
! ======================================================================
#include "../include/list.inc"

module integer_list
    use iso_fortran_env

    implicit none; private

    public :: add, &
              get, &
              insert, &
              clear, &
              remove, &
              assignment(=), &
              sizeof


    type, public :: item_integer(k)
        integer, kind :: k = kind(1_int32)
        integer(kind=k) :: content
    end type

	interface assignment(=)
        module procedure :: assign_item_int8
        module procedure :: assign_item_int16
        module procedure :: assign_item_int32
        module procedure :: assign_item_int64
    end interface

    interface add
        module procedure :: add_item_int8
        module procedure :: add_range_int8
        module procedure :: add_item_int16
        module procedure :: add_range_int16
        module procedure :: add_item_int32
        module procedure :: add_range_int32
        module procedure :: add_item_int64
        module procedure :: add_range_int64
    end interface

    interface clear
        module procedure  :: clear_item_int8
        module procedure  :: clear_item_int16
        module procedure  :: clear_item_int32
        module procedure  :: clear_item_int64
    end interface
    
    interface get
        module procedure  :: get_item_int8
        module procedure  :: get_item_int16
        module procedure  :: get_item_int32
        module procedure  :: get_item_int64
    end interface
    
    interface insert
        module procedure :: insert_item_int8
        module procedure :: insert_item_int16
        module procedure :: insert_item_int32
        module procedure :: insert_item_int64
    end interface
    
    interface remove
        module procedure :: remove_item_int8
        module procedure :: remove_item_int16
        module procedure :: remove_item_int32
        module procedure :: remove_item_int64
    end interface
    
    interface sizeof
        module procedure  :: size_item_int8
        module procedure  :: size_item_int16
        module procedure  :: size_item_int32
        module procedure  :: size_item_int64
    end interface
	
	contains

	
	subroutine assign_item_int8(lhs, rhs)
        integer(kind=int8), intent(inout)  ::  lhs
        class(item_integer(int8)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine
	
	subroutine assign_item_int16(lhs, rhs)
        integer(kind=int16), intent(inout)  ::  lhs
        class(item_integer(int16)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine
	
	subroutine assign_item_int32(lhs, rhs)
        integer(kind=int32), intent(inout)  ::  lhs
        class(item_integer(int32)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine
	
	subroutine assign_item_int64(lhs, rhs)
        integer(kind=int64), intent(inout)  ::  lhs
        class(item_integer(int64)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine

	
	subroutine add_to_int8(vec, val, n, chunk_size, finished)
        type(item_integer(int8)), allocatable, intent(inout) :: vec(:)
        integer(kind=int8), intent(in)            :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_integer(int8)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine
	
	subroutine add_to_int16(vec, val, n, chunk_size, finished)
        type(item_integer(int16)), allocatable, intent(inout) :: vec(:)
        integer(kind=int16), intent(in)            :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_integer(int16)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine
	
	subroutine add_to_int32(vec, val, n, chunk_size, finished)
        type(item_integer(int32)), allocatable, intent(inout) :: vec(:)
        integer(kind=int32), intent(in)            :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_integer(int32)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine
	
	subroutine add_to_int64(vec, val, n, chunk_size, finished)
        type(item_integer(int64)), allocatable, intent(inout) :: vec(:)
        integer(kind=int64), intent(in)            :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_integer(int64)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine

	
	subroutine add_item_int8(this, arg)
        type(item_integer(int8)), intent(inout), allocatable  :: this(:)
        integer(kind=int8), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_int8(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine
	
	subroutine add_item_int16(this, arg)
        type(item_integer(int16)), intent(inout), allocatable  :: this(:)
        integer(kind=int16), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_int16(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine
	
	subroutine add_item_int32(this, arg)
        type(item_integer(int32)), intent(inout), allocatable  :: this(:)
        integer(kind=int32), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_int32(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine
	
	subroutine add_item_int64(this, arg)
        type(item_integer(int64)), intent(inout), allocatable  :: this(:)
        integer(kind=int64), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_int64(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine

	
	subroutine add_range_int8(this, args)
        type(item_integer(int8)), intent(inout), allocatable  :: this(:)
        integer(kind=int8), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_int8(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine
	
	subroutine add_range_int16(this, args)
        type(item_integer(int16)), intent(inout), allocatable  :: this(:)
        integer(kind=int16), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_int16(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine
	
	subroutine add_range_int32(this, args)
        type(item_integer(int32)), intent(inout), allocatable  :: this(:)
        integer(kind=int32), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_int32(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine
	
	subroutine add_range_int64(this, args)
        type(item_integer(int64)), intent(inout), allocatable  :: this(:)
        integer(kind=int64), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_int64(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine

	
	subroutine clear_item_int8(this)
        type(item_integer(int8)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_integer(int8)), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine
	
	subroutine clear_item_int16(this)
        type(item_integer(int16)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_integer(int16)), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine
	
	subroutine clear_item_int32(this)
        type(item_integer(int32)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_integer(int32)), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine
	
	subroutine clear_item_int64(this)
        type(item_integer(int64)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_integer(int64)), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine

	
	function get_item_int8(this, key) result(res)
        type(item_integer(int8)), intent(inout) :: this(:)
        integer, intent(in) :: key
        integer(kind=int8), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function
	
	function get_item_int16(this, key) result(res)
        type(item_integer(int16)), intent(inout) :: this(:)
        integer, intent(in) :: key
        integer(kind=int16), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function
	
	function get_item_int32(this, key) result(res)
        type(item_integer(int32)), intent(inout) :: this(:)
        integer, intent(in) :: key
        integer(kind=int32), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function
	
	function get_item_int64(this, key) result(res)
        type(item_integer(int64)), intent(inout) :: this(:)
        integer, intent(in) :: key
        integer(kind=int64), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function

	
	subroutine insert_item_int8(this, i, arg)
        type(item_integer(int8)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                          :: i
        integer(kind=int8), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_int8(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine
	
	subroutine insert_item_int16(this, i, arg)
        type(item_integer(int16)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                          :: i
        integer(kind=int16), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_int16(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine
	
	subroutine insert_item_int32(this, i, arg)
        type(item_integer(int32)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                          :: i
        integer(kind=int32), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_int32(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine
	
	subroutine insert_item_int64(this, i, arg)
        type(item_integer(int64)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                          :: i
        integer(kind=int64), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_int64(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine

	
	subroutine remove_item_int8(this, i)
        type(item_integer(int8)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_integer(int8)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine
	
	subroutine remove_item_int16(this, i)
        type(item_integer(int16)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_integer(int16)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine
	
	subroutine remove_item_int32(this, i)
        type(item_integer(int32)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_integer(int32)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine
	
	subroutine remove_item_int64(this, i)
        type(item_integer(int64)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_integer(int64)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine

	
	integer function size_item_int8(this) result(res)
        type(item_integer(int8)), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
	
	integer function size_item_int16(this) result(res)
        type(item_integer(int16)), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
	
	integer function size_item_int32(this) result(res)
        type(item_integer(int32)), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
	
	integer function size_item_int64(this) result(res)
        type(item_integer(int64)), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
end module

module real_list
    use iso_fortran_env

    implicit none; private

    public :: add, &
              get, &
              insert, &
              clear, &
              remove, &
              assignment(=), &
              sizeof


    type, public :: item_real(k)
        integer, kind :: k = kind(1.0_real64)
        real(kind=k) :: content
    end type

	interface assignment(=)
        module procedure :: assign_item_real32
        module procedure :: assign_item_real64
        module procedure :: assign_item_real128
    end interface

    interface add
        module procedure :: add_item_real32
        module procedure :: add_range_real32
        module procedure :: add_item_real64
        module procedure :: add_range_real64
        module procedure :: add_item_real128
        module procedure :: add_range_real128
    end interface

    interface clear
        module procedure  :: clear_item_real32
        module procedure  :: clear_item_real64
        module procedure  :: clear_item_real128
    end interface
    
    interface get
        module procedure  :: get_item_real32
        module procedure  :: get_item_real64
        module procedure  :: get_item_real128
    end interface
    
    interface insert
        module procedure :: insert_item_real32
        module procedure :: insert_item_real64
        module procedure :: insert_item_real128
    end interface
    
    interface remove
        module procedure :: remove_item_real32
        module procedure :: remove_item_real64
        module procedure :: remove_item_real128
    end interface
    
    interface sizeof
        module procedure  :: size_item_real32
        module procedure  :: size_item_real64
        module procedure  :: size_item_real128
    end interface
	
	contains

	
	subroutine assign_item_real32(lhs, rhs)
        real(kind=real32), intent(inout)  ::  lhs
        class(item_real(real32)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine
	
	subroutine assign_item_real64(lhs, rhs)
        real(kind=real64), intent(inout)  ::  lhs
        class(item_real(real64)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine
	
	subroutine assign_item_real128(lhs, rhs)
        real(kind=real128), intent(inout)  ::  lhs
        class(item_real(real128)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine

	
	subroutine add_to_real32(vec, val, n, chunk_size, finished)
        type(item_real(real32)), allocatable, intent(inout) :: vec(:)
        real(kind=real32), intent(in)            :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_real(real32)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine
	
	subroutine add_to_real64(vec, val, n, chunk_size, finished)
        type(item_real(real64)), allocatable, intent(inout) :: vec(:)
        real(kind=real64), intent(in)            :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_real(real64)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine
	
	subroutine add_to_real128(vec, val, n, chunk_size, finished)
        type(item_real(real128)), allocatable, intent(inout) :: vec(:)
        real(kind=real128), intent(in)            :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_real(real128)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine

	
	subroutine add_item_real32(this, arg)
        type(item_real(real32)), intent(inout), allocatable  :: this(:)
        real(kind=real32), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_real32(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine
	
	subroutine add_item_real64(this, arg)
        type(item_real(real64)), intent(inout), allocatable  :: this(:)
        real(kind=real64), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_real64(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine
	
	subroutine add_item_real128(this, arg)
        type(item_real(real128)), intent(inout), allocatable  :: this(:)
        real(kind=real128), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_real128(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine

	
	subroutine add_range_real32(this, args)
        type(item_real(real32)), intent(inout), allocatable  :: this(:)
        real(kind=real32), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_real32(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine
	
	subroutine add_range_real64(this, args)
        type(item_real(real64)), intent(inout), allocatable  :: this(:)
        real(kind=real64), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_real64(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine
	
	subroutine add_range_real128(this, args)
        type(item_real(real128)), intent(inout), allocatable  :: this(:)
        real(kind=real128), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_real128(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine

	
	subroutine clear_item_real32(this)
        type(item_real(real32)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_real(real32)), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine
	
	subroutine clear_item_real64(this)
        type(item_real(real64)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_real(real64)), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine
	
	subroutine clear_item_real128(this)
        type(item_real(real128)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_real(real128)), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine

	
	function get_item_real32(this, key) result(res)
        type(item_real(real32)), intent(inout) :: this(:)
        integer, intent(in) :: key
        real(kind=real32), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function
	
	function get_item_real64(this, key) result(res)
        type(item_real(real64)), intent(inout) :: this(:)
        integer, intent(in) :: key
        real(kind=real64), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function
	
	function get_item_real128(this, key) result(res)
        type(item_real(real128)), intent(inout) :: this(:)
        integer, intent(in) :: key
        real(kind=real128), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function

	
	subroutine insert_item_real32(this, i, arg)
        type(item_real(real32)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                          :: i
        real(kind=real32), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_real32(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine
	
	subroutine insert_item_real64(this, i, arg)
        type(item_real(real64)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                          :: i
        real(kind=real64), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_real64(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine
	
	subroutine insert_item_real128(this, i, arg)
        type(item_real(real128)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                          :: i
        real(kind=real128), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_real128(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine

	
	subroutine remove_item_real32(this, i)
        type(item_real(real32)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_real(real32)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine
	
	subroutine remove_item_real64(this, i)
        type(item_real(real64)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_real(real64)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine
	
	subroutine remove_item_real128(this, i)
        type(item_real(real128)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_real(real128)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine

	
	integer function size_item_real32(this) result(res)
        type(item_real(real32)), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
	
	integer function size_item_real64(this) result(res)
        type(item_real(real64)), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
	
	integer function size_item_real128(this) result(res)
        type(item_real(real128)), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
end module

module logical_list
    use iso_fortran_env

    implicit none; private

    public :: add, &
              get, &
              insert, &
              clear, &
              remove, &
              assignment(=), &
              sizeof

    integer, parameter :: log32 = kind(.true.)

    type, public :: item_logical(k)
        integer, kind :: k = kind(.true.)
        logical(kind=k) :: content
    end type

	interface assignment(=)
        module procedure :: assign_item_log32
    end interface

    interface add
        module procedure :: add_item_log32
        module procedure :: add_range_log32
    end interface

    interface clear
        module procedure  :: clear_item_log32
    end interface
    
    interface get
        module procedure  :: get_item_log32
    end interface
    
    interface insert
        module procedure :: insert_item_log32
    end interface
    
    interface remove
        module procedure :: remove_item_log32
    end interface
    
    interface sizeof
        module procedure  :: size_item_log32
    end interface
	
	contains

	
	subroutine assign_item_log32(lhs, rhs)
        logical(kind=log32), intent(inout)  ::  lhs
        class(item_logical(log32)), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine

	
	subroutine add_to_log32(vec, val, n, chunk_size, finished)
        type(item_logical(log32)), allocatable, intent(inout) :: vec(:)
        logical(kind=log32), intent(in)            :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_logical(log32)), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine

	
	subroutine add_item_log32(this, arg)
        type(item_logical(log32)), intent(inout), allocatable  :: this(:)
        logical(kind=log32), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_log32(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine

	
	subroutine add_range_log32(this, args)
        type(item_logical(log32)), intent(inout), allocatable  :: this(:)
        logical(kind=log32), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_log32(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine

	
	subroutine clear_item_log32(this)
        type(item_logical(log32)), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
        type(item_logical(log32)), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine

	
	function get_item_log32(this, key) result(res)
        type(item_logical(log32)), intent(inout) :: this(:)
        integer, intent(in) :: key
        logical(kind=log32), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function

	
	subroutine insert_item_log32(this, i, arg)
        type(item_logical(log32)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                          :: i
        logical(kind=log32), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_log32(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine

	
	subroutine remove_item_log32(this, i)
        type(item_logical(log32)), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_logical(log32)), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine

	
	integer function size_item_log32(this) result(res)
        type(item_logical(log32)), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
end module

module character_list
    use iso_fortran_env

    implicit none; private

    public :: add, &
              get, &
              insert, &
              clear, &
              remove, &
              assignment(=), &
              sizeof

    integer, parameter :: char8 = kind('a') 

    type, public :: item_character
        character(:), allocatable :: content
    end type

	interface assignment(=)
        module procedure :: assign_item_
    end interface

    interface add
        module procedure :: add_item_
        module procedure :: add_range_
    end interface

    interface clear
        module procedure  :: clear_item_
    end interface
    
    interface get
        module procedure  :: get_item_
    end interface
    
    interface insert
        module procedure :: insert_item_
    end interface
    
    interface remove
        module procedure :: remove_item_
    end interface
    
    interface sizeof
        module procedure  :: size_item_
    end interface
	
	contains

	
	subroutine assign_item_(lhs, rhs)
        character(:), allocatable, intent(inout)  ::  lhs
        class(item_character), intent(in)   ::  rhs

        lhs = rhs%content
    end subroutine

	
	subroutine add_to_(vec, val, n, chunk_size, finished)
        type(item_character), allocatable, intent(inout) :: vec(:)
        character(len=*), intent(in)               :: val
        integer, intent(inout)                  			    :: n
        integer, intent(in)                     			    :: chunk_size
        logical, intent(in)                     			    :: finished
        !private
        type(item_character), allocatable :: tmp(:), tmp2(:)
        integer :: csize
        csize = chunk_size

        if (finished) csize = 1
        if (allocated(vec)) then
            if (n == size(vec)) then
                ! have to add another chunk:
                allocate (tmp(size(vec) + csize))
                tmp(1:size(vec)) = vec
                call move_alloc(tmp, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp)
#endif
            end if
            n = n + 1
        else
            ! the first element:
            allocate (vec(csize))
            n = 1
        end if

        vec(n)%content = val

        if (finished) then
            if (n /= size(vec)) then
                allocate (tmp2(n), source=vec(1:n))
                call move_alloc(tmp2, vec)
#ifdef __INTEL_FORTRAN
                deallocate(tmp2)
#endif
            end if
        end if
    end subroutine

	
	subroutine add_item_(this, arg)
        type(item_character), intent(inout), allocatable  :: this(:)
        character(len=*), intent(in)             :: arg
        !private
        integer :: count
        count = size(this)
        call add_to_(this, arg, count, BUFFER_SIZE, finished=.true.)
    end subroutine

	
	subroutine add_range_(this, args)
        type(item_character), intent(inout), allocatable  :: this(:)
        character(len=*), intent(in)             :: args(:)
        !private
        integer :: i, n, count

        n = size(args)
        count = size(this)
        do i = 1, n
            call add_to_(this, args(i), count, BUFFER_SIZE, finished=i == n)
        end do
    end subroutine

	
	subroutine clear_item_(this)
        type(item_character), intent(inout), allocatable :: this(:)
#ifdef __GFORTRAN__
       type(item_character), allocatable :: tmp(:)
        
        allocate (tmp(0))
        this = tmp
#else
        if (allocated(this)) deallocate (this)
        allocate (this(0))
#endif
    end subroutine

	
	function get_item_(this, key) result(res)
       type(item_character), intent(inout) :: this(:)
        integer, intent(in) :: key
        character(len=:), allocatable :: res
        !private
        integer :: n
        n = sizeof(this)
        
        if (key > 0 .and. key <= n) then
            res = this(key)
        end if
    end function

	
	subroutine insert_item_(this, i, arg)
        type(item_character), intent(inout), allocatable  :: this(:)
        integer, intent(in)                              :: i
        character(len=*), intent(in) :: arg
        !private
        integer :: j, count

        count = size(this)
        call add_to_(this, arg, count, BUFFER_SIZE, finished=.true.)

        do j = count, i + 1, -1
            this(j) = this(j - 1)
        end do
        this(i)%content = arg
    end subroutine

	
	subroutine remove_item_(this, i)
        type(item_character), intent(inout), allocatable  :: this(:)
        integer, intent(in)                                       :: i
        !private
        type(item_character), allocatable :: tmp(:)
        integer :: j, n

        n = size(this)
        
        do j = i, n - 1
            this(j) = this(j + 1)
        end do
        
        allocate (tmp(n - 1), source = this(1:n - 1))
        call move_alloc(tmp, this)
    end subroutine

	
	integer function size_item_(this) result(res)
        type(item_character), intent(inout), allocatable  :: this(:)
        if (.not. allocated(this)) then 
            res = 0
        else
            res = size(this)
        end if
    end function
end module

module intrinsic_list
    use iso_fortran_env
    use integer_list
    use real_list
    use logical_list
    use character_list
end module